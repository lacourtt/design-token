import StyleDictionary from 'style-dictionary';

async function build() {

    const config = {
        source: ['tokens/**/*.json'],

        // ---------------------------------------------------------
        // FIX: 'parsers' must be at the ROOT level, not inside hooks
        // ---------------------------------------------------------
        hooks: {
            parsers: {
                'custom-json-parser': {
                    pattern: /\.json$/,
                    parser: ({ contents, filePath }) => {
                        // simple log to confirm it's running
                        console.log(`Processing ${filePath} with custom parser...`);

                        const obj = JSON.parse(contents);

                        // Determine type based on file path
                        let type = undefined;
                        if (filePath.includes('strings.json')) {
                            type = 'content';
                        } else if (filePath.includes('color.json')) {
                            type = 'color';
                        }

                        // Recursive function to wrap strings in { value: ... }
                        function wrapValues(node) {
                            for (const key in node) {
                                if (typeof node[key] === 'string') {
                                    node[key] = { value: node[key] };
                                    if (type) {
                                        node[key].type = type;
                                    }
                                } else if (typeof node[key] === 'object') {
                                    wrapValues(node[key]);
                                }
                            }
                        }

                        wrapValues(obj);
                        return obj;
                    }
                }
            },
            // Formats still live in hooks because we reference them by name
            formats: {
                'custom/compose/colors': ({ dictionary }) => {
                    return `package com.dicane.dicompose.theme

import androidx.compose.ui.graphics.Color

// Generated by Style Dictionary
${dictionary.allTokens.map(prop => {
                        let hex = prop.value.replace('#', '');
                        if (hex.length === 6) {
                            hex = 'FF' + hex;
                        }
                        return `val ${prop.name} = Color(0x${hex.toUpperCase()})`;
                    }).join('\n')}`;
                }
            },
            transforms: {
                'custom/name': {
                    type: 'name',
                    transform: (token) => {
                        if (token.type === 'color') {
                            // Return the name directly (e.g. "OnPrimary")
                            return token.path[token.path.length - 1];
                        }
                        // For strings, return the key as is (snake_case from JSON)
                        return token.path[token.path.length - 1];
                    }
                }
            }
        },

        parsers: ['custom-json-parser'],

        platforms: {
            // --- ANDROID CONFIGURATION ---
            android: {
                transforms: ['attribute/cti', 'custom/name'],
                buildPath: '../android-app/',
                files: [
                    {
                        // Color.kt
                        destination: 'dicompose/src/main/java/com/dicane/dicompose/theme/Color.kt',
                        format: 'custom/compose/colors',
                        filter: (token) => token.path[0] === 'color'
                    },
                    {
                        // strings.xml
                        destination: 'breeder/src/main/res/values/strings.xml',
                        format: 'android/strings',
                        // Matches the top-level key "string" in your strings.json
                        filter: (token) => token.path[0] === 'string',
                        options: {
                            outputStringKey: (token) => token.name
                        }
                    }
                ]
            }
        }
    };

    try {
        const sd = new StyleDictionary(config);
        await sd.buildAllPlatforms();
        console.log('âœ… Design Tokens updated successfully.');
    } catch (e) {
        console.error('Build failed:', e);
    }
}

build();